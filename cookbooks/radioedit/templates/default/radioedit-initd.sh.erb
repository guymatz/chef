#!/usr/bin/env bash
# #################################################
# @FILE: 
# @AUTHOR: GregoryPatmore <gregorypatmore@clearchannel.com>}
# @CHEF-COOKBOOK: radioedit
# @PROJECT: Radioedit Epona Launch
# @TICKETID: OPS-5792
# @TAB-SIZE: 2
# @SOFT-TABS: YES
# @DESC: SystemV init.d script to manage the radioedit application server process.
# @NOTES: 
# #################################################

# Source function library.
. /etc/rc.d/init.d/functions 
# Get config.
. /etc/sysconfig/network 

# Check that networking is up.
if [ "${NETWORKING}" = "no" ]; then
  error "**Error: $0 : Networking seems to be unavailable";
  # logger -s -p user.error "**Error: $0 : Networking seems to be unavailable";
  exit 1;
fi

# handle to the supervisorctl command
SCTL="<%= @supervisorctl_path %>";
# name of the app module to manage
APPNAME="<%= @application_name %>";
# any setenv file that needs to be sourced
SETENV="<%= @setenv_file %>";
# user to execute the commands as
RUNAS="<%= @runas_user %>"
# path to the pid file
PIDFILE="<%= @pid_file %>";

# # make sure we can execute on the supervisor daemon
# [[ -x /etc/init.d/supervisor ]] \
#   && error "**Error: $0 : Supervisor daemon service missing or not executable" \
#   && exit 1;

# make sure we can execute the supervisorctl command
[[ -x $SCTL ]] \
  && error "**Error: $0 : Supervisor CTL command missing or not executable" \
  && exit 1;

# make sure we got a pid file to write to.
[[ -z "${PIDFILE}" ]] \
  && error "**Error: $0 : No pid file path given" \
  && exit 1;

#@TODO: check that supervisor is running

# start the application withiin supervisor
function start_app() {
  # source a setenv if one has been set
  [[ -f $SETENV 2>/dev/null ]] \
    && . $SETENV;

  result=$($SCTL start $APPNAME);
  [[ $result -ne 0 ]] \
    && error "**Error: $0 : Call to start application (${APPNAME}) exited with unclean status (${result})" \
    && exit 1;

  # @TODO: Register the pid file with sysv
};

# stop the application within supervisor
function stop_app() {
  result=$($SCTL stop $APPNAME);
  [[ $result -ne 0 ]] \
    && error "**Error: $0 : Call to stop application (${APPNAME}) exited with unclean status (${result})" \
    && exit 1;
};

# print the status of the app 
function status_app() {
  result=$($SCTL status $APPNAME | grep $APPNAME);
  # if no results, the app is not running.
  [[ -z "${result}" ]] \
    && echo "${APPNAME} not running" \
    && exit 0;

  echo "${APPNAME}: $(echo ${result} | awk '{print $2}')" 

}

# print the usage message 
function show_usage() {
 echo "Usage: $0 {start|stop|restart|status}"
};

# argument processing
case "$1" in

  start) 
    start_app;
    ;;

  stop) 
    stop_app;
    ;;

  restart)
    stop_app \
      && sleep 5 \ 
      && start_app;
    ;;

  status)
    status_app;
    ;;

  *)
    show_usage \
      && exit 0; 
    ;;

esac

exit $?;












# #!/bin/sh
# #
# # <daemonname> <summary>
# #
# # chkconfig:   <default runlevel(s)> <start> <stop>
# # description: <description, split multiple lines with \
# #              a backslash>

# ### BEGIN INIT INFO
# # Provides: 
# # Required-Start: 
# # Required-Stop: 
# # Should-Start: 
# # Should-Stop: 
# # Default-Start: 
# # Default-Stop: 
# # Short-Description: 
# # Description:      
# ### END INIT INFO

# # Source function library.
# . /etc/rc.d/init.d/functions

# exec="/path/to/<daemonname>"
# prog="<service name>"
# config="<path to major config file>"

# [ -e /etc/sysconfig/$prog ] && . /etc/sysconfig/$prog

# lockfile=/var/lock/subsys/$prog

# start() {
#     [ -x $exec ] || exit 5
#     [ -f $config ] || exit 6
#     echo -n $"Starting $prog: "
#     # if not running, start it up here, usually something like "daemon $exec"
#     retval=$?
#     echo
#     [ $retval -eq 0 ] && touch $lockfile
#     return $retval
# }

# stop() {
#     echo -n $"Stopping $prog: "
#     # stop it here, often "killproc $prog"
#     retval=$?
#     echo
#     [ $retval -eq 0 ] && rm -f $lockfile
#     return $retval
# }

# restart() {
#     stop
#     start
# }

# reload() {
#     restart
# }

# force_reload() {
#     restart
# }

# rh_status() {
#     # run checks to determine if the service is running or use generic status
#     status $prog
# }

# rh_status_q() {
#     rh_status >/dev/null 2>&1
# }


# case "$1" in
#     start)
#         rh_status_q && exit 0
#         $1
#         ;;
#     stop)
#         rh_status_q || exit 0
#         $1
#         ;;
#     restart)
#         $1
#         ;;
#     reload)
#         rh_status_q || exit 7
#         $1
#         ;;
#     force-reload)
#         force_reload
#         ;;
#     status)
#         rh_status
#         ;;
#     condrestart|try-restart)
#         rh_status_q || exit 0
#         restart
#         ;;
#     *)
#         echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}"
#         exit 2
# esac
# exit $?